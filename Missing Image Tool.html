<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B2C Commerce Missing Image Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Public+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Public Sans', sans-serif;
        }
        /* A simple spinner for the analyze button */
        .loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900 mb-2">B2C Commerce Missing Image Analyzer</h1>
            <p class="text-gray-600">Find assigned product images that are missing from your WebDAV server.</p>
        </div>

        <!-- Main Form -->
        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-lg space-y-8">
            
            <!-- Instructions Section -->
            <div>
                <details class="bg-gray-50 p-4 rounded-lg border">
                    <summary class="font-semibold cursor-pointer text-lg text-gray-800">Click here for instructions</summary>
                    <div class="mt-4 space-y-4 text-gray-700 border-t pt-4">
                        <div>
                            <h3 class="text-md font-semibold mb-2">How It Works</h3>
                            <p class="text-sm">
                                This tool analyzes <strong>online products</strong> (where online-flag="true") that are assigned to categories in your storefront catalog. It identifies two types of image issues:
                                <ol class="list-decimal list-inside pl-4 mt-2 text-xs">
                                    <li><strong>Missing Image Group:</strong> Products that do not have an <strong>&lt;image-group&gt;</strong> with a `view-type` matching the View Type you provide.</li>
                                    <li><strong>Missing Image File:</strong> Products that have the correct image group, but the image file specified in the <strong>&lt;image path="..."/&gt;</strong> tag is not found on the WebDAV server.</li>
                                </ol>
                                Offline products are automatically ignored. The tool recursively scans your entire WebDAV folder to find all available image files for the comparison.
                            </p>
                        </div>
                        <div>
                            <h3 class="text-md font-semibold mb-2">How to Use</h3>
                            <ol class="list-decimal list-inside space-y-3 text-sm">
                                <li>
                                    <strong>Upload Catalog Files:</strong> Use the fields in Section 1 to upload your master and storefront catalog XML files.
                                    <ul class="list-disc list-inside ml-4 mt-2 space-y-1 text-xs text-gray-600">
                                        <li><strong>File Size Limit:</strong> Files must be under ~100 MB due to browser memory limits</li>
                                        <li><strong>Too Large?</strong> Export filtered catalogs from Business Manager (filter by online status, categories, or date range)</li>
                                        <li><strong>Tip:</strong> Process products in batches if your full catalog is too large</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Configure Instance & Paths:</strong> Fill in all the details for your B2C Commerce instance in Section 2.
                                    <ul class="list-disc list-inside ml-4 mt-2 space-y-1 text-xs text-gray-600">
                                        <li><strong>View Type (optional):</strong> Leave empty to check all image view types, or specify a view type (e.g., "large", "small") to check only that type.</li>
                                        <li><strong>WebDAV Folder URL:</strong> The full URL to the root folder for your images. (e.g., `https://.../images/`). Must end with a `/`.</li>
                                        <li><strong>Username:</strong> Your Account Manager email address.</li>
                                        <li><strong>Password:</strong> Your WebDAV File Access / UX Studio access key from Business Manager.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Start Analysis:</strong> Click the "Analyze Imagery" button. The log will show real-time progress.
                                </li>
                                <li>
                                    <strong>Download Results:</strong> Once complete, a "Download CSV" button will appear. The CSV will contain the product ID, the reason for the issue, and the specific image path if applicable.
                                </li>
                            </ol>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Step 1: File Inputs -->
            <div>
                <h2 class="text-xl font-semibold mb-4 pb-2 border-b">1. Upload Catalog Files</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label for="product-catalog-file" class="block text-sm font-medium text-gray-700 mb-1">Master Catalog</label>
                        <input id="product-catalog-file" type="file" accept=".xml" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors" required>
                    </div>
                    <div>
                        <label for="storefront-catalog-file" class="block text-sm font-medium text-gray-700 mb-1">Storefront Catalog</label>
                        <input id="storefront-catalog-file" type="file" accept=".xml" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors" required>
                    </div>
                </div>
            </div>

            <!-- Step 2: WebDAV Inputs -->
            <div>
                <h2 class="text-xl font-semibold mb-4 pb-2 border-b">2. Configure Instance & Paths</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label for="view-type" class="block text-sm font-medium text-gray-700">View Type <span class="text-gray-400 font-normal">(optional)</span></label>
                        <input type="text" id="view-type" placeholder="e.g., large, small, swatch (leave empty for all types)" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                        <p class="mt-1 text-xs text-gray-500">Leave empty to check all image view types, or specify one to check only that type.</p>
                    </div>
                    <div class="md:col-span-2">
                         <label for="webdav-url" class="block text-sm font-medium text-gray-700">WebDAV Folder URL</label>
                        <input type="text" id="webdav-url" placeholder="https://your-realm.demandware.net/.../images/" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="username" class="block text-sm font-medium text-gray-700">Username</label>
                        <input type="text" id="username" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                        <input type="password" id="password" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                </div>
            </div>

            <!-- Step 3: Action Button -->
            <div>
                <button id="analyze-button" class="w-full flex items-center justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-base font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 transition-transform transform hover:scale-105">
                    <span id="button-text">Analyze Imagery</span>
                    <div id="button-loader" class="loader ml-2 hidden"></div>
                </button>
            </div>
        </div>

        <!-- Status & Results -->
        <div id="status-container" class="mt-8 bg-white p-6 md:p-8 rounded-2xl shadow-lg hidden">
            <h2 class="text-xl font-semibold mb-4">Analysis Log</h2>
            <pre id="log-output" class="bg-gray-900 text-white text-sm rounded-md p-4 h-64 overflow-y-auto whitespace-pre-wrap"></pre>
            <div id="results-container" class="mt-6 text-center hidden">
                 <h3 id="results-summary" class="text-lg font-semibold my-2 text-gray-800"></h3>
                 <button id="download-csv-button" class="inline-block py-2 px-6 border border-transparent rounded-md shadow-sm text-base font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-transform transform hover:scale-105">Download Missing Images CSV</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const productCatalogInput = document.getElementById('product-catalog-file');
        const storefrontCatalogInput = document.getElementById('storefront-catalog-file');
        const viewTypeInput = document.getElementById('view-type');
        const webdavUrlInput = document.getElementById('webdav-url');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const analyzeButton = document.getElementById('analyze-button');
        const buttonText = document.getElementById('button-text');
        const buttonLoader = document.getElementById('button-loader');
        const statusContainer = document.getElementById('status-container');
        const logOutput = document.getElementById('log-output');
        const resultsContainer = document.getElementById('results-container');
        const resultsSummary = document.getElementById('results-summary');
        const downloadCsvButton = document.getElementById('download-csv-button');

        let finalMissingProducts = [];

        // --- Logger Function ---
        function log(message) {
            console.log(message);
            logOutput.textContent += message + '\n';
            logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll to bottom
        }

        // --- File Reader Helper ---
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        }
        
        // --- Custom WebDAV Client using Fetch API ---
        async function getAllWebdavFilesRecursive(hostname, remotePath, username, password, basePathToStrip) {
             try {
                log(`Recursively scanning WebDAV directory: ${remotePath}... This may take a moment.`);
                
                const filepaths = new Set();
                const authHeader = 'Basic ' + btoa(username + ':' + password);
                
                // PROPFIND request to get all files recursively
                const propfindBody = `<?xml version="1.0" encoding="utf-8" ?>
                    <D:propfind xmlns:D="DAV:">
                        <D:allprop/>
                    </D:propfind>`;
                
                const response = await fetch(hostname + remotePath, {
                    method: 'PROPFIND',
                    headers: {
                        'Authorization': authHeader,
                        'Content-Type': 'application/xml; charset=utf-8',
                        'Depth': 'infinity'
                    },
                    body: propfindBody
                });
                
                if (!response.ok) {
                    throw new Error(`WebDAV request failed: ${response.status} ${response.statusText}`);
                }
                
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
                
                // Parse the WebDAV response
                const responses = xmlDoc.getElementsByTagNameNS('DAV:', 'response');
                
                for (let i = 0; i < responses.length; i++) {
                    const response = responses[i];
                    const href = response.getElementsByTagNameNS('DAV:', 'href')[0]?.textContent;
                    const resourceType = response.getElementsByTagNameNS('DAV:', 'resourcetype')[0];
                    const isCollection = resourceType?.getElementsByTagNameNS('DAV:', 'collection').length > 0;
                    
                    // Only process files, not directories
                    if (href && !isCollection) {
                        // Decode URL encoding
                        let normalizedPath = decodeURIComponent(href);
                        
                        // Remove leading slash
                        normalizedPath = normalizedPath.startsWith('/') ? normalizedPath.substring(1) : normalizedPath;
                        
                        // Strip the base path if it exists
                        if (basePathToStrip) {
                            const baseToStrip = basePathToStrip.startsWith('/') ? basePathToStrip.substring(1) : basePathToStrip;
                            if (normalizedPath.startsWith(baseToStrip)) {
                                normalizedPath = normalizedPath.substring(baseToStrip.length);
                            }
                        }
                        
                        // Normalize: replace backslashes, lowercase, remove leading/trailing slashes and spaces
                        normalizedPath = normalizedPath.replace(/\\/g, '/').toLowerCase().trim().replace(/^\/+|\/+$/g, '');
                        if (normalizedPath) {
                            filepaths.add(normalizedPath);
                        }
                    }
                }
                
                log(`--> Found ${filepaths.size} total files in all sub-directories.`);
                
                // Log a few sample paths to help with debugging
                if (filepaths.size > 0) {
                    const samples = Array.from(filepaths).slice(0, 3);
                    log(`--> Sample normalized paths: ${samples.join(', ')}${filepaths.size > 3 ? '...' : ''}`);
                }
                
                return filepaths;
            } catch (error) {
                log(`Error scanning WebDAV path ${remotePath}: ${error.message}`);
                console.error(error);
                return new Set(); // Return empty set on error to allow process to continue
            }
        }

        // --- Main Analysis Logic ---
        async function analyze() {
            // 1. UI Reset & Validation
            analyzeButton.disabled = true;
            buttonText.textContent = "Analyzing...";
            buttonLoader.classList.remove('hidden');
            statusContainer.classList.remove('hidden');
            resultsContainer.classList.add('hidden');
            logOutput.textContent = '';
            finalMissingProducts = [];

            const viewType = viewTypeInput.value.trim();
            const webdavUrl = webdavUrlInput.value.trim();

            if (!productCatalogInput.files[0] || !storefrontCatalogInput.files[0] || !webdavUrl || !usernameInput.value) {
                log('Error: Please select both catalog files and fill in WebDAV URL and username.');
                resetUI();
                return;
            }
            if (!webdavUrl.endsWith('/')) {
                log('Error: "WebDAV Folder URL" must end with a forward slash (/).');
                resetUI();
                return;
            }

            let hostname, remoteLibraryPath;
            try {
                const fullUrl = new URL(webdavUrl);
                hostname = fullUrl.origin;
                remoteLibraryPath = fullUrl.pathname;
            } catch (e) {
                log('Error: Invalid "WebDAV Folder URL". Please provide a full, valid URL.');
                resetUI();
                return;
            }

            try {
                // 2. Read and Parse XML files
                log('Reading and parsing catalog files...');
                const parser = new DOMParser();
                
                // Read master catalog
                log('--> Reading master catalog file...');
                const productCatalogFile = productCatalogInput.files[0];
                const masterSizeMB = productCatalogFile.size / 1024 / 1024;
                log(`    File: ${productCatalogFile.name} (${masterSizeMB.toFixed(2)} MB)`);
                
                // Check file size - browsers typically struggle with files over 100MB
                const MAX_FILE_SIZE_MB = 100;
                if (masterSizeMB > MAX_FILE_SIZE_MB) {
                    log(`Error: Master catalog file is too large (${masterSizeMB.toFixed(2)} MB).`);
                    log(`Browser memory limits prevent processing files larger than ~${MAX_FILE_SIZE_MB} MB.`);
                    log('');
                    log('Solutions:');
                    log('1. Export a filtered catalog containing only products you need to check');
                    log('2. Filter by online-flag, specific categories, or date range');
                    log('3. Use Business Manager\'s export filters to reduce catalog size');
                    log('4. Process products in batches by exporting smaller catalog segments');
                    resetUI();
                    return;
                }
                
                const productCatalogText = await readFileAsText(productCatalogFile);
                
                // Read storefront catalog
                log('--> Reading storefront catalog file...');
                const storefrontCatalogFile = storefrontCatalogInput.files[0];
                const storefrontSizeMB = storefrontCatalogFile.size / 1024 / 1024;
                log(`    File: ${storefrontCatalogFile.name} (${storefrontSizeMB.toFixed(2)} MB)`);
                
                // Check storefront catalog size
                if (storefrontSizeMB > MAX_FILE_SIZE_MB) {
                    log(`Error: Storefront catalog file is too large (${storefrontSizeMB.toFixed(2)} MB).`);
                    log(`Browser memory limits prevent processing files larger than ~${MAX_FILE_SIZE_MB} MB.`);
                    log('Please export a smaller/filtered version of the storefront catalog.');
                    resetUI();
                    return;
                }
                
                const storefrontCatalogText = await readFileAsText(storefrontCatalogFile);
                
                // Parse master catalog
                log('--> Parsing master catalog XML...');
                // Remove default namespace (xmlns) to make querySelector work reliably.
                const productCatalogTextClean = productCatalogText.replace(/xmlns=".*?"/g, '');
                const productCatalogDoc = parser.parseFromString(productCatalogTextClean, "application/xml");
                
                // Check for parsing errors in master catalog
                const masterError = productCatalogDoc.querySelector('parsererror');
                if (masterError) {
                    log('Error: Failed to parse master catalog XML file.');
                    log('Parser error details:');
                    log(masterError.textContent.substring(0, 500)); // Show first 500 chars of error
                    log('Please ensure the XML file is well-formed and not corrupted.');
                    resetUI();
                    return;
                }
                const allProducts = productCatalogDoc.querySelectorAll('product');
                const onlineProducts = productCatalogDoc.querySelectorAll('product[online-flag="true"]');
                const offlineProducts = allProducts.length - onlineProducts.length;
                log(`    ✓ Master catalog parsed successfully (${allProducts.length} products found)`);
                log(`      └─ ${onlineProducts.length} online products (will be analyzed)`);
                log(`      └─ ${offlineProducts} offline products (will be ignored)`);
                
                // Parse storefront catalog
                log('--> Parsing storefront catalog XML...');
                const storefrontCatalogTextClean = storefrontCatalogText.replace(/xmlns=".*?"/g, '');
                const storefrontCatalogDoc = parser.parseFromString(storefrontCatalogTextClean, "application/xml");
                
                // Check for parsing errors in storefront catalog
                const storefrontError = storefrontCatalogDoc.querySelector('parsererror');
                if (storefrontError) {
                    log('Error: Failed to parse storefront catalog XML file.');
                    log('Parser error details:');
                    log(storefrontError.textContent.substring(0, 500)); // Show first 500 chars of error
                    log('Please ensure the XML file is well-formed and not corrupted.');
                    resetUI();
                    return;
                }
                log(`    ✓ Storefront catalog parsed successfully (${storefrontCatalogDoc.querySelectorAll('category-assignment').length} category assignments found)`);

                // 3. Build variant-to-master map (only for online products)
                log('Building variant-to-master map for online products...');
                const variantToMasterMap = new Map();
                productCatalogDoc.querySelectorAll('product[online-flag="true"] > variations > variants > variant').forEach(variant => {
                    const master = variant.closest('product');
                    if (master) {
                        const variantId = variant.getAttribute('product-id');
                        const masterId = master.getAttribute('product-id');
                        variantToMasterMap.set(variantId, masterId);
                    }
                });
                log(`--> Mapped ${variantToMasterMap.size} variants to their online master products.`);

                // 4. Get categorized products from storefront catalog
                log(`Finding all categorized products from storefront catalog...`);
                const categorizedProducts = new Set([...storefrontCatalogDoc.querySelectorAll('category-assignment')].map(el => el.getAttribute('product-id')));
                log(`--> Found ${categorizedProducts.size} unique products assigned to categories.`);
                
                // 5. Check each categorized product for image groups and paths
                const checkAllViewTypes = !viewType || viewType.trim() === '';
                const viewTypeMessage = checkAllViewTypes ? 'all view types' : `view-type='${viewType}'`;
                log(`Analyzing products for missing image groups (${viewTypeMessage})...`);
                const pathsToCheck = new Map(); // Map<normalizedPath, {productId, originalPath, viewType}>
                let variantsMappedCount = 0;
                let productsNotFoundCount = 0;

                categorizedProducts.forEach(categorizedProductId => {
                    let productToAnalyzeId = categorizedProductId;
                    
                    // If the categorized ID is a variant, we need to find its master to check for images.
                    if (variantToMasterMap.has(categorizedProductId)) {
                        productToAnalyzeId = variantToMasterMap.get(categorizedProductId);
                        variantsMappedCount++;
                    }

                    const productEl = productCatalogDoc.querySelector(`product[product-id="${productToAnalyzeId}"]`);
                    
                    // If we can't find a product definition (master or standalone) for the categorized ID, skip it.
                    if (!productEl) {
                        productsNotFoundCount++;
                        return;
                    }
                    
                    // Check if product is online - skip offline products
                    const onlineFlag = productEl.getAttribute('online-flag');
                    if (onlineFlag !== 'true') {
                        productsNotFoundCount++;
                        return;
                    }
                    
                    // Get all image groups or specific view type
                    const imageGroups = checkAllViewTypes 
                        ? productEl.querySelectorAll('images > image-group')
                        : productEl.querySelectorAll(`images > image-group[view-type="${viewType}"]`);

                    // The image group will always be on the master/standalone product element
                    if (imageGroups.length === 0) {
                        // Condition A: Missing the entire image group(s)
                        const reason = checkAllViewTypes 
                            ? 'Missing image groups (no image groups found)'
                            : `Missing image group for view-type '${viewType}'`;
                        finalMissingProducts.push({
                            productId: categorizedProductId, // Report the original ID from the category assignment
                            reason: reason,
                            imagePath: '',
                            viewType: viewType || 'all'
                        });
                    } else {
                        // Condition B: Group(s) exist, so check the paths within them
                        let hasAnyImages = false;
                        
                        imageGroups.forEach(imageGroup => {
                            const groupViewType = imageGroup.getAttribute('view-type');
                            const imagePathsInGroup = imageGroup.querySelectorAll('image[path]');
                            
                            if (imagePathsInGroup.length > 0) {
                                hasAnyImages = true;
                                imagePathsInGroup.forEach(imageEl => {
                                    const originalPath = imageEl.getAttribute('path');
                                    // Normalize: replace backslashes, lowercase, remove leading/trailing slashes and spaces
                                    const normalizedPath = originalPath.replace(/\\/g, '/').toLowerCase().trim().replace(/^\/+|\/+$/g, '');
                                    // Report the original ID in the map for checking
                                    if (normalizedPath) {
                                        pathsToCheck.set(normalizedPath, { 
                                            productId: categorizedProductId, 
                                            originalPath,
                                            viewType: groupViewType 
                                        });
                                    }
                                });
                            }
                        });
                        
                        if (!hasAnyImages) {
                            const reason = checkAllViewTypes 
                                ? 'Image groups exist but are empty'
                                : `Image group for view-type '${viewType}' exists but is empty`;
                            finalMissingProducts.push({
                                productId: categorizedProductId,
                                reason: reason,
                                imagePath: '',
                                viewType: viewType || 'all'
                            });
                        }
                    }
                });
                
                if (variantsMappedCount > 0) {
                    log(`--> Mapped ${variantsMappedCount} variant products to their master products.`);
                }
                if (productsNotFoundCount > 0) {
                    log(`--> Warning: ${productsNotFoundCount} categorized products not found in master catalog (skipped).`);
                    
                    // If a large percentage of products are missing, warn about potential catalog mismatch
                    const missingPercentage = (productsNotFoundCount / categorizedProducts.size) * 100;
                    if (missingPercentage > 50) {
                        log(`--> ℹ️  Note: ${missingPercentage.toFixed(0)}% of products not found in master catalog. Possible reasons:`);
                        log(`    • Mismatched catalogs (e.g., CI storefront + STG master) - ensure same hierarchy`);
                        log(`    • Using a partial/test master catalog file`);
                        log(`    • Products exist in storefront but not yet defined in master`);
                    }
                }
                
                log(`--> Found ${finalMissingProducts.length} products with image group issues.`);
                log(`--> Found ${pathsToCheck.size} unique image paths to check against WebDAV.`);
                
                // Log a few sample catalog paths to help with debugging
                if (pathsToCheck.size > 0) {
                    const samplePaths = Array.from(pathsToCheck.keys()).slice(0, 3);
                    log(`--> Sample catalog paths: ${samplePaths.join(', ')}${pathsToCheck.size > 3 ? '...' : ''}`);
                }
                
                // 6. Connect to WebDAV and check for missing files
                if (pathsToCheck.size > 0) {
                    try {
                        log('Connecting to WebDAV server...');
                        
                        // Use custom WebDAV client (no external library needed!)
                        const actualFiles = await getAllWebdavFilesRecursive(
                            hostname, 
                            remoteLibraryPath, 
                            usernameInput.value, 
                            passwordInput.value,
                            remoteLibraryPath
                        );

                        log(`Checking ${pathsToCheck.size} image paths against WebDAV files...`);
                        let missingFileCount = 0;
                        pathsToCheck.forEach(({ productId, originalPath, viewType: imgViewType }, normalizedPath) => {
                            if (!actualFiles.has(normalizedPath)) {
                                missingFileCount++;
                                finalMissingProducts.push({
                                    productId: productId, // Use the original ID from the map
                                    reason: 'File not found on WebDAV',
                                    imagePath: originalPath,
                                    viewType: imgViewType || viewType || 'all'
                                });
                            }
                        });
                        log(`--> Found ${missingFileCount} missing image files on WebDAV.`);
                    } catch (webdavError) {
                        log('------------------------------------------');
                        log(`⚠️  WebDAV connection error: ${webdavError.message}`);
                        log('Please check your WebDAV URL, username, and password.');
                        log('Continuing with image group analysis only...');
                        log('------------------------------------------');
                    }
                } else {
                    log('No image paths to check against WebDAV (all products have missing/empty image groups).');
                }
                
                // 7. Display final results
                log('------------------------------------------');
                log('Analysis Complete!');
                
                // Count issue types for summary
                const missingGroupCount = finalMissingProducts.filter(p => p.reason.includes('Missing image group')).length;
                const emptyGroupCount = finalMissingProducts.filter(p => p.reason.includes('exists but is empty')).length;
                const missingWebDAVCount = finalMissingProducts.filter(p => p.reason === 'File not found on WebDAV').length;
                
                const viewTypeSummary = checkAllViewTypes ? 'all view types' : `view-type '${viewType}'`;
                log(`Summary (checking ${viewTypeSummary}):`);
                log(`  - ${missingGroupCount} products missing image groups`);
                log(`  - ${emptyGroupCount} products with empty image groups`);
                log(`  - ${missingWebDAVCount} products with image paths not found on WebDAV`);
                log(`  - Total: ${finalMissingProducts.length} issues`);
                
                resultsSummary.textContent = `Found ${finalMissingProducts.length} total issues: ${missingGroupCount} missing image groups, ${emptyGroupCount} empty groups, ${missingWebDAVCount} missing files.`;
                resultsContainer.classList.remove('hidden');

            } catch (error) {
                log('A critical error occurred: ' + error.message);
                console.error(error);
            } finally {
                resetUI(true);
            }
        }
        
        function resetUI(isFinished = false) {
             analyzeButton.disabled = false;
             buttonText.textContent = isFinished ? "Run New Analysis" : "Analyze Imagery";
             buttonLoader.classList.add('hidden');
        }

        // --- CSV Download Logic ---
        function downloadCSV() {
            if (finalMissingProducts.length === 0) {
                alert("No missing images to export.");
                return;
            }
            let csvContent = "data:text/csv;charset=utf-8,";
            const headers = ["product_id", "reason", "missing_image_path"];
            csvContent += headers.join(",") + "\n";

            finalMissingProducts.forEach(item => {
                const row = [
                    `"${item.productId}"`,
                    `"${item.reason}"`,
                    `"${item.imagePath}"`
                ];
                csvContent += row.join(",") + "\n";
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "missing_image_report.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- Event Listeners ---
        analyzeButton.addEventListener('click', analyze);
        downloadCsvButton.addEventListener('click', downloadCSV);
        
        // --- Page Load Message ---
        window.addEventListener('DOMContentLoaded', () => {
            console.log('✓ Missing Image Tool loaded successfully!');
            console.log('Using built-in WebDAV client (Fetch API) - no external libraries required.');
            console.log('Current protocol:', window.location.protocol);
            
            if (window.location.protocol === 'file:') {
                console.warn('⚠️  Opening via file:// protocol may cause CORS issues with WebDAV.');
                console.warn('   For best results, serve via HTTP: python3 -m http.server 8000');
            }
        });

    </script>
</body>
</html>

